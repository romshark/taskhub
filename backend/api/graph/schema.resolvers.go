package graph

// // This file will be automatically regenerated based on the schema, any resolver implementations
// // will be copied through when generating and any unknown code will be moved to the end.
// // Code generated by github.com/99designs/gqlgen version v0.17.34

// import (
// 	"context"

// 	"github.com/romshark/taskhub/api/graph/auth"
// 	"github.com/romshark/taskhub/api/graph/model"
// 	"github.com/romshark/taskhub/slices"
// )

// // Tasks is the resolver for the tasks field.
// func (r *projectResolver) Tasks(ctx context.Context, obj *model.Project) ([]*model.Task, error) {
// 	if err := auth.RequireAuthenticated(ctx); err != nil {
// 		return nil, err
// 	}

// 	tasks := []*model.Task{}
// 	for _, t := range r.Resolver.Tasks {
// 		if t.Project == obj {
// 			tasks = append(tasks, t)
// 		}
// 	}
// 	return tasks, nil
// }

// // Members is the resolver for the members field.
// func (r *projectResolver) Members(ctx context.Context, obj *model.Project) ([]*model.User, error) {
// 	if err := auth.RequireAuthenticated(ctx); err != nil {
// 		return nil, err
// 	}

// 	m := []*model.User{}
// 	for _, t := range r.Resolver.Tasks {
// 		if t.Project != obj {
// 			continue
// 		}
// 		for _, u := range t.Assignees {
// 			m = slices.AppendUnique(m, u)
// 		}
// 		for _, u := range t.Reporters {
// 			m = slices.AppendUnique(m, u)
// 		}
// 	}
// 	return m, nil
// }

// // IsBlockedBy is the resolver for the isBlockedBy field.
// func (r *taskResolver) IsBlockedBy(ctx context.Context, obj *model.Task) ([]*model.Task, error) {
// 	blockedBy := []*model.Task{}
// 	for _, t := range r.Resolver.Tasks {
// 		if t == obj {
// 			continue
// 		}
// 		for _, t := range t.Blocks {
// 			if t == obj {
// 				blockedBy = slices.AppendUnique(blockedBy, t)
// 			}
// 		}
// 	}
// 	return blockedBy, nil
// }

// // RelatesTo is the resolver for the relatesTo field.
// func (r *taskResolver) RelatesTo(ctx context.Context, obj *model.Task) ([]*model.Task, error) {
// 	relatesTo := []*model.Task{}
// 	relatesTo = append(relatesTo, obj.RelatesTo...)
// 	for _, t := range r.Resolver.Tasks {
// 		if t == obj {
// 			continue
// 		}
// 		for _, tr := range t.RelatesTo {
// 			if tr == obj {
// 				relatesTo = slices.AppendUnique(relatesTo, tr)
// 			}
// 		}
// 	}
// 	return relatesTo, nil
// }

// // Projects is the resolver for the projects field.
// func (r *userResolver) Projects(ctx context.Context, obj *model.User) ([]*model.Project, error) {
// 	p := []*model.Project{}
// 	for _, t := range r.Resolver.Tasks {
// 		for _, u := range t.Assignees {
// 			if u == obj {
// 				p = slices.AppendUnique(p, t.Project)
// 				break
// 			}
// 		}
// 		for _, u := range t.Reporters {
// 			if u == obj {
// 				p = slices.AppendUnique(p, t.Project)
// 				break
// 			}
// 		}
// 	}
// 	return p, nil
// }

// // TasksAssigned is the resolver for the tasksAssigned field.
// func (r *userResolver) TasksAssigned(ctx context.Context, obj *model.User) ([]*model.Task, error) {
// 	tasks := []*model.Task{}
// 	for _, t := range r.Tasks {
// 		for _, r := range t.Assignees {
// 			if r == obj {
// 				tasks = append(tasks, t)
// 			}
// 		}
// 	}
// 	return tasks, nil
// }

// // TasksReported is the resolver for the tasksReported field.
// func (r *userResolver) TasksReported(ctx context.Context, obj *model.User) ([]*model.Task, error) {
// 	tasks := []*model.Task{}
// 	for _, t := range r.Tasks {
// 		for _, r := range t.Reporters {
// 			if r == obj {
// 				tasks = append(tasks, t)
// 			}
// 		}
// 	}
// 	return tasks, nil
// }

// // Project returns ProjectResolver implementation.
// func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

// // Task returns TaskResolver implementation.
// func (r *Resolver) Task() TaskResolver { return &taskResolver{r} }

// // User returns UserResolver implementation.
// func (r *Resolver) User() UserResolver { return &userResolver{r} }

// type projectResolver struct{ *Resolver }
// type taskResolver struct{ *Resolver }
// type userResolver struct{ *Resolver }
