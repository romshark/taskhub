package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/romshark/taskhub/graph/model"
	"github.com/romshark/taskhub/slices"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, displayName string, role string, location string, manager *string, subordinates []string) (*model.User, error) {
	for _, u := range r.Resolver.Users {
		if u.DisplayName == displayName {
			return nil, errors.New("non-unique displayName")
		}
	}
	if err := ValidateUserDisplayName(displayName); err != nil {
		return nil, err
	}
	if err := ValidateUserRole(role); err != nil {
		return nil, err
	}
	if err := ValidateUserLocation(location); err != nil {
		return nil, err
	}

	var managerUser *model.User
	if manager != nil {
		managerUser = UserByID(r.Resolver, *manager)
		if managerUser == nil {
			return nil, fmt.Errorf("manager user %q not found", *manager)
		}
	}

	var subordinateUsers []*model.User
	for _, s := range subordinates {
		u := UserByID(r.Resolver, s)
		if u == nil {
			return nil, fmt.Errorf("subordinate user %q not found", s)
		}
	}

	newUser := &model.User{
		ID:           "user_" + MakeID(displayName),
		DisplayName:  displayName,
		Role:         role,
		Location:     location,
		Manager:      managerUser,
		Subordinates: subordinateUsers,
	}
	r.Resolver.Users = append(r.Resolver.Users, newUser)
	return newUser, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, displayName string, role string, location string, personalStatus *string, manager *string, subordinates []string) (*model.User, error) {
	user := UserByID(r.Resolver, id)
	if user == nil {
		return nil, fmt.Errorf("user %q not found", id)
	}

	for _, u := range r.Resolver.Users {
		if u.DisplayName == displayName {
			return nil, errors.New("non-unique displayName")
		}
	}
	if err := ValidateUserDisplayName(displayName); err != nil {
		return nil, err
	}
	if err := ValidateUserRole(role); err != nil {
		return nil, err
	}
	if err := ValidateUserLocation(location); err != nil {
		return nil, err
	}

	var personalStatusText string
	if personalStatus != nil {
		personalStatusText = *personalStatus
		err := ValidateUserPersonalStatus(personalStatusText)
		if err != nil {
			return nil, err
		}
	}

	var managerUser *model.User
	if manager != nil {
		managerUser = UserByID(r.Resolver, *manager)
		if managerUser == nil {
			return nil, fmt.Errorf("manager user %q not found", *manager)
		}
	}

	var subordinateUsers []*model.User
	for _, s := range subordinates {
		u := UserByID(r.Resolver, s)
		if u == nil {
			return nil, fmt.Errorf("subordinate user %q not found", s)
		}
	}

	user.DisplayName = displayName
	user.Role = role
	user.Location = location
	user.PersonalStatus = personalStatusText
	user.Manager = managerUser
	user.Subordinates = subordinateUsers

	return user, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, title string, project string, status model.TaskStatus, priority model.TaskPriority, description *string, due *time.Time, tags []string, assignees []string, reporters []string) (*model.Task, error) {
	for _, t := range r.Resolver.Tasks {
		if t.Title == title {
			return nil, errors.New("non-unique title")
		}
	}
	if err := ValidateTaskTitle(title); err != nil {
		return nil, err
	}
	for _, t := range tags {
		if err := ValidateTaskTag(t); err != nil {
			return nil, err
		}
	}

	assignedProject := ProjectByID(r.Resolver, project)
	if assignedProject == nil {
		return nil, fmt.Errorf("project %q not found", project)
	}

	var usersAssignees []*model.User
	for _, id := range assignees {
		user := UserByID(r.Resolver, id)
		if user == nil {
			return nil, fmt.Errorf("assignee user %q not found", id)
		}
		usersAssignees = slices.AppendUnique(usersAssignees, user)
	}

	var usersReporters []*model.User
	for _, id := range assignees {
		u := UserByID(r.Resolver, id)
		if u == nil {
			return nil, fmt.Errorf("reporter user %q not found", id)
		}
		usersReporters = slices.AppendUnique(usersReporters, u)
	}

	newTask := &model.Task{
		ID:          "task_" + MakeID(title),
		Title:       title,
		Description: description,
		Priority:    priority,
		Status:      status,
		Creation:    time.Now(),
		Due:         due,
		Tags:        tags,
		Project:     assignedProject,
		Assignees:   usersAssignees,
		Reporters:   usersReporters,
	}
	r.Tasks = append(r.Tasks, newTask)
	return newTask, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, title string, description *string, status model.TaskStatus, priority model.TaskPriority, due *time.Time, tags []string, project string, assignees []string, reporters []string, blocks []string, relatesTo []string) (*model.Task, error) {
	task := TaskByID(r.Resolver, id)
	if task == nil {
		return nil, fmt.Errorf("task %q not found", id)
	}

	for _, t := range r.Resolver.Tasks {
		if t.Title == title {
			return nil, errors.New("non-unique title")
		}
	}
	if err := ValidateTaskTitle(title); err != nil {
		return nil, err
	}
	for _, t := range tags {
		if err := ValidateTaskTag(t); err != nil {
			return nil, err
		}
	}

	var assignedProject *model.Project
	for _, p := range r.Resolver.Projects {
		if p.ID == project {
			assignedProject = p
			break
		}
	}
	if assignedProject == nil {
		return nil, fmt.Errorf("project %q not found", project)
	}

	var usersAssignees []*model.User
	for _, id := range assignees {
		user := UserByID(r.Resolver, id)
		if user == nil {
			return nil, fmt.Errorf("assignee user %q not found", id)
		}
		usersAssignees = slices.AppendUnique(usersAssignees, user)
	}

	var usersReporters []*model.User
	for _, id := range assignees {
		u := UserByID(r.Resolver, id)
		if u == nil {
			return nil, fmt.Errorf("reporter user %q not found", id)
		}
		usersReporters = slices.AppendUnique(usersReporters, u)
	}

	var blocksTasks []*model.Task
	for _, id := range blocks {
		t := TaskByID(r.Resolver, id)
		if t == nil {
			return nil, fmt.Errorf("blocked task %q not found", id)
		}
		blocksTasks = slices.AppendUnique(blocksTasks, t)
	}

	var relatesToTasks []*model.Task
	for _, id := range relatesTo {
		t := TaskByID(r.Resolver, id)
		if t == nil {
			return nil, fmt.Errorf("related task %q not found", id)
		}
		relatesToTasks = slices.AppendUnique(relatesToTasks, t)
	}

	task.Status = status
	task.Priority = priority
	task.Description = description
	task.Tags = tags
	task.Due = due
	task.Reporters = usersReporters
	task.Title = title
	task.Project = assignedProject
	task.Assignees = usersAssignees
	task.Blocks = blocksTasks
	task.RelatesTo = relatesToTasks

	return task, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, name string, description string, slug string, owners []string) (*model.Project, error) {
	if err := ValidateProjectName(name); err != nil {
		return nil, err
	}
	if err := ValidateProjectDescription(description); err != nil {
		return nil, err
	}
	if err := ValidateProjectSlug(slug); err != nil {
		return nil, err
	}

	var ownerUsers []*model.User
	for _, id := range owners {
		u := UserByID(r.Resolver, id)
		if u == nil {
			return nil, fmt.Errorf("owner user %q not found", id)
		}
		ownerUsers = append(ownerUsers, u)
	}

	newProject := &model.Project{
		ID:          "project_" + MakeID(name),
		Name:        name,
		Description: description,
		Slug:        slug,
		Creation:    time.Now(),
		Owners:      ownerUsers,
	}
	return newProject, nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, name string, description string, slug string, owners []string) (*model.Project, error) {
	project := ProjectByID(r.Resolver, id)
	if project == nil {
		return nil, fmt.Errorf("project %q not found", id)
	}

	if err := ValidateProjectName(name); err != nil {
		return nil, err
	}
	if err := ValidateProjectDescription(description); err != nil {
		return nil, err
	}
	if err := ValidateProjectSlug(slug); err != nil {
		return nil, err
	}

	var ownerUsers []*model.User
	for _, id := range owners {
		u := UserByID(r.Resolver, id)
		if u == nil {
			return nil, fmt.Errorf("owner user %q not found", id)
		}
		ownerUsers = append(ownerUsers, u)
	}

	newProject := &model.Project{
		ID:          "project_" + MakeID(name),
		Name:        name,
		Description: description,
		Slug:        slug,
		Creation:    time.Now(),
		Owners:      ownerUsers,
	}
	return newProject, nil
}

// Tasks is the resolver for the tasks field.
func (r *projectResolver) Tasks(ctx context.Context, obj *model.Project) ([]*model.Task, error) {
	tasks := []*model.Task{}
	for _, t := range r.Resolver.Tasks {
		if t.Project == obj {
			tasks = append(tasks, t)
		}
	}
	return tasks, nil
}

// Members is the resolver for the members field.
func (r *projectResolver) Members(ctx context.Context, obj *model.Project) ([]*model.User, error) {
	m := []*model.User{}
	for _, t := range r.Resolver.Tasks {
		if t.Project != obj {
			continue
		}
		for _, u := range t.Assignees {
			m = slices.AppendUnique(m, u)
		}
		for _, u := range t.Reporters {
			m = slices.AppendUnique(m, u)
		}
	}
	return m, nil
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	for _, t := range r.Resolver.Tasks {
		if t.ID == id {
			return t, nil
		}
	}
	return nil, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	for _, u := range r.Resolver.Users {
		if u.ID == id {
			return u, nil
		}
	}
	return nil, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	for _, p := range r.Resolver.Projects {
		if p.ID == id {
			return p, nil
		}
	}
	return nil, nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, filters *model.TasksFilters, order *model.TasksOrder, orderAsc bool, limit *int) ([]*model.Task, error) {
	tasks := slices.Copy(r.Resolver.Tasks)
	if filters != nil {
		if filters.CreatedAfter != nil {
			tasks = slices.FilterInPlace(tasks, func(t *model.Task) (ok bool) {
				return t.Creation.Unix() > filters.CreatedAfter.Unix()
			})
			if len(tasks) < 1 {
				return nil, nil
			}
		}
		if filters.CreatedBefore != nil {
			tasks = slices.FilterInPlace(tasks, func(t *model.Task) (ok bool) {
				return t.Creation.Unix() < filters.CreatedBefore.Unix()
			})
			if len(tasks) < 1 {
				return nil, nil
			}
		}
		if filters.Assignees != nil {
			tasks = slices.FilterInPlace(tasks, func(t *model.Task) (ok bool) {
				return slices.IsSubsetGet(filters.Assignees, t.Assignees, GetUserID)
			})
			if len(tasks) < 1 {
				return nil, nil
			}
		}
		if filters.Reporters != nil {
			tasks = slices.FilterInPlace(tasks, func(t *model.Task) (ok bool) {
				return slices.IsSubsetGet(filters.Reporters, t.Reporters, GetUserID)
			})
			if len(tasks) < 1 {
				return nil, nil
			}
		}
		if filters.Tags != nil {
			tasks = slices.FilterInPlace(tasks, func(t *model.Task) (ok bool) {
				return slices.IsSubset(filters.Tags, t.Tags)
			})
			if len(tasks) < 1 {
				return nil, nil
			}
		}
		if filters.Status != nil {
			tasks = slices.FilterInPlace(tasks, func(t *model.Task) (ok bool) {
				return slices.Contains(filters.Status, t.Status)
			})
			if len(tasks) < 1 {
				return nil, nil
			}
		}
		if filters.Projects != nil {
			tasks = slices.FilterInPlace(tasks, func(t *model.Task) (ok bool) {
				return t.Project != nil &&
					slices.Contains(filters.Projects, t.Project.ID)
			})
			if len(tasks) < 1 {
				return nil, nil
			}
		}
	}
	return slices.SortAndLimit(tasks, SortFnTasks(order, orderAsc), Limit(limit)), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, filters *model.UsersFilters, order *model.UsersOrder, orderAsc bool, limit *int) ([]*model.User, error) {
	users := slices.Copy(r.Resolver.Users)
	if filters != nil {
		if filters.Projects != nil {
			users = slices.FilterInPlace(users, func(u *model.User) (ok bool) {
				p := []string{}
				for _, t := range r.Resolver.Tasks {
					for _, a := range t.Assignees {
						if a == u {
							p = slices.AppendUnique(p, t.Project.ID)
							break
						}
					}
					for _, a := range t.Reporters {
						if a == u {
							p = slices.AppendUnique(p, t.Project.ID)
							break
						}
					}
				}
				return slices.IsSubset(filters.Projects, p)
			})
			if len(users) < 1 {
				return nil, nil
			}
		}
	}
	return slices.SortAndLimit(users, SortFnUsers(order, orderAsc), Limit(limit)), nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, filters *model.ProjectsFilters, order *model.ProjectsOrder, orderAsc bool, limit *int) ([]*model.Project, error) {
	projects := slices.Copy(r.Resolver.Projects)
	if filters != nil {
		if filters.CreatedAfter != nil {
			projects = slices.FilterInPlace(projects, func(p *model.Project) (ok bool) {
				return p.Creation.Unix() > filters.CreatedAfter.Unix()
			})
			if len(projects) < 1 {
				return nil, nil
			}
		}
		if filters.CreatedBefore != nil {
			projects = slices.FilterInPlace(projects, func(p *model.Project) (ok bool) {
				return p.Creation.Unix() < filters.CreatedBefore.Unix()
			})
			if len(projects) < 1 {
				return nil, nil
			}
		}
		if filters.Members != nil {
			projects = slices.FilterInPlace(projects, func(p *model.Project) (ok bool) {
				memberIDs := []string{}
				for _, t := range r.Resolver.Tasks {
					if t.Project != p {
						continue
					}
					for _, u := range t.Assignees {
						memberIDs = slices.AppendUnique(memberIDs, u.ID)
					}
					for _, u := range t.Reporters {
						memberIDs = slices.AppendUnique(memberIDs, u.ID)
					}
				}
				return slices.IsSubset(filters.Members, memberIDs)
			})
			if len(projects) < 1 {
				return nil, nil
			}
		}
	}
	return slices.SortAndLimit(
		projects,
		SortFnProjects(order, orderAsc, r.Resolver),
		Limit(limit),
	), nil
}

// IsBlockedBy is the resolver for the isBlockedBy field.
func (r *taskResolver) IsBlockedBy(ctx context.Context, obj *model.Task) ([]*model.Task, error) {
	blockedBy := []*model.Task{}
	for _, t := range r.Resolver.Tasks {
		if t == obj {
			continue
		}
		for _, t := range t.Blocks {
			if t == obj {
				blockedBy = slices.AppendUnique(blockedBy, t)
			}
		}
	}
	return blockedBy, nil
}

// RelatesTo is the resolver for the relatesTo field.
func (r *taskResolver) RelatesTo(ctx context.Context, obj *model.Task) ([]*model.Task, error) {
	relatesTo := []*model.Task{}
	relatesTo = append(relatesTo, obj.RelatesTo...)
	for _, t := range r.Resolver.Tasks {
		if t == obj {
			continue
		}
		for _, tr := range t.RelatesTo {
			if tr == obj {
				relatesTo = slices.AppendUnique(relatesTo, tr)
			}
		}
	}
	return relatesTo, nil
}

// Projects is the resolver for the projects field.
func (r *userResolver) Projects(ctx context.Context, obj *model.User) ([]*model.Project, error) {
	p := []*model.Project{}
	for _, t := range r.Resolver.Tasks {
		for _, u := range t.Assignees {
			if u == obj {
				p = slices.AppendUnique(p, t.Project)
				break
			}
		}
		for _, u := range t.Reporters {
			if u == obj {
				p = slices.AppendUnique(p, t.Project)
				break
			}
		}
	}
	return p, nil
}

// TasksAssigned is the resolver for the tasksAssigned field.
func (r *userResolver) TasksAssigned(ctx context.Context, obj *model.User) ([]*model.Task, error) {
	tasks := []*model.Task{}
	for _, t := range r.Tasks {
		for _, r := range t.Assignees {
			if r == obj {
				tasks = append(tasks, t)
			}
		}
	}
	return tasks, nil
}

// TasksReported is the resolver for the tasksReported field.
func (r *userResolver) TasksReported(ctx context.Context, obj *model.User) ([]*model.Task, error) {
	tasks := []*model.Task{}
	for _, t := range r.Tasks {
		for _, r := range t.Reporters {
			if r == obj {
				tasks = append(tasks, t)
			}
		}
	}
	return tasks, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Project returns ProjectResolver implementation.
func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Task returns TaskResolver implementation.
func (r *Resolver) Task() TaskResolver { return &taskResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type taskResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
